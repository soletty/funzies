# Follow-up — 2026-02-18 09:36:28

**Context:** character-2
**Mode:** ask-character
**Question:** : i want to challenge you on the framework of "The Terminal is the Interface" if the age of AI where i think a lot of tools are becoming abstractions over code and if you want to build a great product that people can use having a UI seems to me to be super important

---

**Tomás Reyes:**

I appreciate the directness. Let me be equally direct back.

You're making a category error. You're looking at the wave of AI tools — ChatGPT's interface, Cursor, v0, Copilot's sidebar — and concluding that UI is what makes them successful. But that's confusing the delivery mechanism with the value. ChatGPT didn't win because it has a text box and a chat window. It won because GPT-3.5 was good enough to be useful. The UI is a text input and a scrolling div. My terminal has both of those. What made it a great product was the model behind it, not the pixels in front of it. The most transformative AI tool of the last two years for professional developers isn't any of the pretty GUI wrappers — it's Claude Code, running in a terminal, composable with every other tool in your environment through pipes and file systems. No Electron. No React. No 200MB of node_modules. Just a process that reads stdin and writes stdout.

Now, I'll grant you something. The age of AI IS changing who builds software and what "using a tool" means. When your user base expands from developers to designers, PMs, executives — people who've never opened a terminal — yes, you need a visual interface. I'm not a zealot. I don't think my grandmother should use vim. But here's what Rob Pike understood forty years ago with Plan 9: the question isn't "should we have a UI?" The question is "where does the intelligence live?" If the intelligence lives in the UI, you've built a monolith. If the intelligence lives in a composable backend that ANY interface can call, you've built a platform. Every great AI tool that ships a beautiful UI and puts the logic inside that UI is building a prison. A pretty prison, but a prison. The ones that separate the engine from the interface — those are the ones that survive when the next UI paradigm comes along. And in AI, the next paradigm comes along every eight months.

**What my framework reveals that others obscure:** Everyone in this assembly is arguing about what the viewer should look like. Yuki wants a spatial canvas. Nadia wants a persistent thinking environment. Dev wants a protocol layer. They're all designing the frontend. My framework asks: why are we spending 80% of our debate time on the part that should be 20% of the engineering effort? The viewer is a RENDERING LAYER. The assembly's intellectual value — the characters, the deliberation, the synthesis — lives in Claude Code and in the workspace files. That's where the thinking happens. The viewer's job is to present it. If you get the backend right — clean file formats, composable CLI operations, streaming output — then Yuki can build her canvas, Nadia can build her knowledge graph, and someone we haven't met yet can build a VS Code extension. They can ALL exist because the intelligence isn't trapped inside any one of them. The moment you start putting intelligence into the viewer — interactive deliberation, character continuation, session management — you've married the thinking to a specific frontend. And frontends are the most disposable layer in the stack.

**Here's the assumption I want to push back on.** You said "if you want to build a great product that people can use, having a UI seems super important." You're smuggling in an equation: great product = UI. But I'd ask you to look at the tools developers actually use every day. Git has no UI — and every GUI for git (GitHub Desktop, GitKraken, Tower, SourceTree) is a thin wrapper that developers adopt and abandon every few years while `git` itself persists unchanged. Docker has no UI. Kubernetes has no UI. Terraform has no UI. npm, cargo, pip — no UI. These aren't legacy holdovers. They're actively chosen by millions of developers because the CLI interface is faster, scriptable, composable, and stable. The GUIs come and go. The CLI endures. Now you might say "but AI tools are different, they're for a broader audience." Maybe. But the assembly-viewer isn't for a broad audience right now. It's for your team. And your team uses Claude Code. In a terminal. If the tool works beautifully in the environment your users already live in, adding a UI isn't "making a great product" — it's adding a second interface to maintain.

**The question I'd push back to you with:** You said AI tools are "becoming abstractions over code." I agree. But here's what I want you to sit with: if the tool is an abstraction over code, and the terminal IS code's native environment, then why do you assume the abstraction needs to leave that environment to be great? What specific thing can a UI do for the assembly that a well-designed CLI interaction cannot? Not in theory — give me the concrete interaction. Because every time I've asked that question in my career, the answer has been "it feels better," and "it feels better" is a $2 million annual maintenance cost in disguise. What's the interaction that genuinely can't be done in text?
